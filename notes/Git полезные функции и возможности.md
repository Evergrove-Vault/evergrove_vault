# Список самых часто используемых команд

В большинстве случаев можно обойтись достаточно базовым набором команд:
- init 
- clone 
- add
- commit 
- checkout
- push 
- pull
- branch 
- merge
- rebase 

> [!info] Различия между merge и rebase 
> **rebase** - позволяет переместить коммиты из одной ветки в цепочку коммитов другой ветки так, будто они изначально там находились
> 
> **merge** - слияние двух веток в одну с созданием коммита слияния. Сохраняет историю до слияния 

> [!hint] Совет
> В случае использования **rebase** в проекте вместо merge **дописывайте в название коммита название ветки**, так потом вам будет намного проще понять откуда пришел данный коммит


Однако возникают ситуации когда простого набора команд становится недостаточно и необходимо решать такие проблемы, как откат коммитов, создание тегов и очистка истории.

[Git пример работы с файлами](https://colab.research.google.com/drive/1FSIsYPfRvnLh-D256_zPLTtXo1Nk26-Z?usp=sharing)
# Более продвинутые команды и их применение

Часть команд и примеров рассматриваются в [этой статье](https://habr.com/ru/companies/ruvds/articles/599929/)
документацию по всем командам ниже можно найти в [официальной доке по git](https://git-scm.com/docs/git#_git_commands) 

**revert** - позволяет создать отменяющий коммит на уже существующий и запушенны в удаленный репозиторий. Является абсолютно безопасным, так как не удаляет изменения в явном виде

**reset** - позволяет возвратить HEAD указатель на какой-то коммит в прошлом, тем самым забыв все новые изменения. Хорошо подходит в случае, если изменения сделаны только локально. Будьте внимательны, так как можете удалить лишнее на совсем 

**switch** - более безопасная альтернатива checkout, так как не дает потерять файлы в случае некорректного выполнения переключения между ветками

**commit --ammend** - позволяет добавить в последний коммит забытые файлы или подправить название коммита.  Хорошо сочетается с rebase -i в случае если коммит не является последним в ветке

**rebase -i** - интерактивный вариант предыдущей команды. Позволяет поменять порядок следования коммитов, их описание, слить несколько коммитов в один, в общем подправить историю изменений так, чтобы она смотрелась максимально хорошо 

**worktree** - позволяет работать над несколькими ветками проекта одновременно, что сильно упрощает ситуацию когда вы не доделали изменения в какой-то ветки, но вынуждены переключиться на другую. [Статья по теме](https://habr.com/ru/articles/826260/) [cheatsheet](https://gist.github.com/ludwigdn/46265813924500b0bc3e95dad6eb7cf8)

**stash** - позволяет временно спрятать часть изменений или все произошедшие после последнего коммита. Это поможет в случае если вам нужно перейти к решению другой задачи, а вы еще не готовы делать новый коммит, или вам надо перенести изменения в несколько других веток  (для этого так же подойдет следующая команда). Более подробную инструкцию по применению смотрите [тут](https://www.atlassian.com/ru/git/tutorials/saving-changes/git-stash)

**cherry-pick** - позволяет копировать коммит в другую ветку. Это бывает очень полезно, когда вам нужно быстро затянуть изменения из другой ветки, не дожидаясь ее слияния. 

>[!attention]
> Черезмерное увлечение данной командой негативно влияет на читаемость веток и не является хорошей практикой. 

**diff** - достаточно мощный инструмент для сравнения версий файлов в вашем репозитории. Идеально подходит в тех случаях, когда вы работаете в консоли на удаленном сервере и не можете воспользоваться визуальным сопоставлением файлов. 

**fetch** - позволяет только скачать новые изменения с сервера. В отличии от pull не применяет их к локальным веткам. Хорошо подходит для случаев проведения code review, так как позволяет протестировать новые PR локально

**tag** - позволяет поставить метку на конкретный коммит в коде, который в дальнейшем можно использовать например для нужд релизов

**blame** - отслеживание авторства строк кода

**maintenance** - позволяет git проводить оптимизацию хранения данных, тем самым ускоряя   действие других команд в больших репозиториях 