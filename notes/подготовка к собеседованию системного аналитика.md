---
tags:
  - unstruct
---

https://habr.com/ru/articles/814769/

# Какие технологии, методы и инструменты надо посмотреть 



 
	  


# Что надо учесть 
нужно учитывать:
- требования по конфиденциальности клиентов
- хранению и аудиту данных
- возможность прохождения внутренних и внешних проверок

передавать модели только ту информацию, которая действительно необходима для задачи

как и где вызывается LLM через API
Важно продумать кэширование результатов

поэтому при необходимости быстрого ответа следует предусмотреть асинхронную обработку, систему уведомлений или fallbacks ("Fallback cache" - **это паттерн, который позволяет системе использовать менее актуальные резервные данные из кеша, когда свежие данные недоступны из-за ошибок или сбоев в источнике данных**.) 
Задать latency 

Выход LLM не следует считать достоверным по умолчанию. Необходимо спроектировать «фильтры» и проверки: например, сервис верификации фактов из внутренней базы знаний, правила на отказ от опасного или запрещенного контента, ручную модерацию для критических операций

**Ограничения API (rate limit, лимиты токенов).** У всех публичных LLM-API есть ограничения на число запросов в минуту и максимальное количество токенов в запросе/ответе. При проектировании нужно уточнить эти лимиты и предусмотреть механизмы очередей или деградации сервиса при достижении порога.

Определить формат взаимодействия 
1. Общие вопросы и требования к интеграции
Цель и границы интеграции

Какую бизнес-задачу решает интеграция?

Какую функциональность мы должны получить «в лоб»?

Какие данные/события передаются, и в каком объёме/частоте?

Нефункциональные требования

Требования по латентности (максимальное время отклика).

Пропускная способность (число запросов/сообщений в единицу времени).

SLA и SLO (доступность, время восстановления).

Масштабируемость (вертикальная/горизонтальная).

Безопасность и комплаенс

Какие данные являются конфиденциальными?

Какие механизмы шифрования (TLS, VPN) требуются?

Аутентификация и авторизация (OAuth2, Mutual TLS, API-ключи).

Логи и аудит: что, где и как долго логируется.

Формат и качество данных

Форматы передаваемых данных (JSON, XML, Protobuf, CSV и пр.).

Версионирование контрактов/схем (schema registry, OpenAPI, GraphQL schema).

Валидация (контроль схемы, бизнес-правил, дедупликация).

Управление ошибками и отказоустойчивость

Как обрабатываются ошибки (retry-policy, DLQ, fallback)?

Порядок очередности и гарантия доставки (at-least-once, exactly-once, at-most-once).

Мониторинг, алерты и трассировка (distributed tracing, метрики).

Организационные моменты

Ответственные лица и команды (контактные лица со стороны партнёра).

Процесс изменения контракта (где и как согласовывать апдейты).

Документация (где хранится спецификация, примеры запросов/ответов).

2. REST API
Базовые параметры

Endpoints (список путей и ресурсы).

HTTP-методы (GET/POST/PUT/PATCH/DELETE) и idempotency.

Статусы ответов и их смысл (2xx, 4xx, 5xx).

Аутентификация/авторизация

OAuth2 (flows: client_credentials, authorization_code).

API-ключи, JWT-токены, Mutual TLS.

Контракты и валидация

Спецификация OpenAPI/Swagger.

Валидация входящего JSON-schema.

Версионирование (в URL, в заголовках).

Пагинация и фильтрация

Механизмы (limit/offset, cursor).

Сортировка и фильтры (query parameters).

Таймауты и повторные попытки

Рекомендуемые таймауты клиент-сервер.

Retry-policy (число попыток, backoff).

Кеширование

ETag/If-None-Match, Cache-Control.

Где хранится кэш (CDN, In-memory).

3. Брокеры сообщений (RabbitMQ, Kafka и пр.)
Топологии и шаблоны

Тип обмена (direct, topic, fanout) или темы/партиции.

Потребители: конкурирующие, групповые.

Форматы сообщений

Используемые сериализаторы (JSON, Avro, Protobuf).

Schema Registry для версионирования.

Гарантии доставки

At-least-once vs exactly-once; транзакции.

Dead-letter queues и политики DLQ.

Требования к производительности

Throughput (сообщений в секунду).

Размер сообщений (максимальный payload).

Мониторинг и алерты

Lag-метрики (consumer lag), depth очередей.

Availability (brokers up/down).

Управление доступом

ACLs, RBAC (разрешения на чтение/запись топиков).

4. gRPC
IDL и контракт

Protobuf-файлы: структура сообщений и сервисов.

Версионирование и обратная совместимость.

Типы RPC

Unary, Server streaming, Client streaming, Bidirectional streaming.

Безопасность

TLS, mTLS, перехватчики (interceptors) для аутентификации.

Хендлеры ошибок

Использование статусов gRPC (OK, CANCELLED, INTERNAL и др.).

Metadata для передачи доп. информации.

Производительность

Keepalive, flow-control, максимальный размер сообщения.

Инструменты и экосистема

Поддержка на клиенте/сервере (языки, библиотеки).

Генерация стубов, интеграция с Envoy/Service Mesh.

5. GraphQL
Схема и резолверы

Типы (Query, Mutation, Subscription) и их поля.

Фрагменты, директивы и аргументы запросов.

Авторизация/аутентификация

Middleware-решения (например, JWT-в резолверах).

Политики доступа на уровне полей (field-level security).

Производительность

Максимальная глубина запроса (query complexity), лимит на число полей.

Кеширование (persisted queries, dataloader для batch-fetching).

Документация и introspection

Включена ли introspection в проде?

Валидация ответов LLM 

Playground/GraphiQL для тестирования.

Версионирование

Как добавляются/удаляются поля без поломки клиентов.

6. Интеграция через базу данных
Тип соединения

Прямой доступ (JDBC/ODBC) или через API-прослойку.

Схема и права доступа

Какие таблицы/вьюшки доступны; права SELECT/INSERT/UPDATE.

Консистентность и изоляция

Уровни изоляции транзакций (READ COMMITTED, SERIALIZABLE).

Периодичность репликаций/синхронизаций.

ETL-процессы

Расписание (batch vs real-time).

Инструменты (Airflow, Talend, Spark).

Мониторинг и алерты

Длительные запросы, lock-конфликты.

7. Интеграция через файлы (FTP, S3 и пр.)
Форматы и кодировки

CSV, JSON, XML, Parquet; разделители, кодировка (UTF-8/CP1251).

Протокол передачи

FTP/SFTP, HTTPS (presigned URLs), SMB.

Организация структуры

Паттерн папок и наименования файлов (даты, идентификаторы).

Гарантии доставки

Atomic pull/push (temp-file → rename).

Проверка контрольных сумм (MD5, SHA).

Периодичность и расписание

Cron-расписание, trigger-ы (S3 events).

Очистка и архивирование

Политики хранения, автo-архив, дедупликация.

Необходимо предусмотреть повторы, резервные варианты (например, сокращённый функционал без LLM) и информирование пользователя о неполадках.






- **Цели проекта:** Какие конкретно бизнес-задачи должна решать система? Например, повысить вовлеченность клиентов, увеличить продажи продуктов, сократить нагрузку саппорта. В каком формате ожидаются рекомендации или ответы?
    
- **Тип системы:** Будет ли это рекомендательная система (проактивные советы клиенту) или диалоговый ассистент/агент (вопрос-ответ, сценарии с пользовательскими командами)? Какие сценарии приоритетны?
    
- **Целевая аудитория:** Кто конечные пользователи (частные клиенты, менеджеры банка, дилеры и т.д.) и через какой интерфейс они будут взаимодействовать (мобильное приложение, веб, терминал, интеграция с CRM)?
    
- **Доступные данные:** Какие данные о клиенте есть (информация аккаунта, история транзакций, демография, профиль рисков)? Есть ли готовые API для доступа к этим данным? Какие данные можно передавать в LLM, а какие – нет?
    
- **Конфиденциальность и согласие:** Требуется ли информировать пользователя о том, что его данные пойдут в LLM (политика конфиденциальности)? Нужен ли соглас для каждой сессии? Какие личные данные должны оставаться внутри банка?
    
- **Нагрузочные характеристики:** Сколько запросов в сутки/час предполагается? Нужно ли обрабатывать миллионы транзакций и отвечать в режиме реального времени, или система может асинхронно строить отчёты?
    
- **Требования к отклику:** Какое максимальное время ожидания приемлемо? Нужно ли prioritizing (например, срочные финансовые вопросы)?
    
- **Интеграции:** С какими конкретно системами нужно взаимодействовать (управление счетами, кредитный скоринг, системы уведомлений и т.д.)? Какие форматы и протоколы интеграции используются в банке (SOAP, REST, gRPC)?
    
- **Критерии качества:** Как измерять успешность решения? Метрики: точность/релевантность рекомендаций, скорость ответа, вовлеченность пользователей, доля успешных транзакций?
    
- **Ограничения безопасности:** Какие стандарты и сертификации релевантны (например, SOC2, ISO27001), нужно ли прохождение внутренней проверки/аудита AI-системы? Какие уровни данных есть и какое шифрование требуется?
    
- **Расчёт стоимости:** Каков бюджет на LLM-сервис (подписка/токены)? Планируются ли разовые затраты на настройку или тонкое обучение?
    
- **Поддержка и обновления:** Кто будет поддерживать систему после ввода в эксплуатацию (DevOps, внутренние AI-инженеры, сторонний подрядчик)? Как часто планируются обновления модели или добавление новых сценариев?
    
- **План развёртывания:** Нужен ли PoC или прототип перед полноценной разработкой? Какие сроки сдачи минимально допустимы?

# Какие типы диаграмм нам нужны 

Диаграммы вариантов использования (Use Case Diagram)
Диаграмма активности (Activity Diagram) **что происходит** внутри одного процесса (логика, условия, шаги).
Диаграмма последовательности (Sequence Diagram) **как объекты взаимодействуют** между собой во времени (сообщения, вызовы).




