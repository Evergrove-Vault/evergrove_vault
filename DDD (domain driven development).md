---
tags:
  - inbox
---

# Материалы

- ### [Статья 1 (теория)](https://habr.com/ru/companies/oleg-bunin/articles/650927/) ^42bead
- ### [Статья 2 (практика)](https://habr.com/ru/companies/oleg-bunin/articles/661129/)
- ### [Коротко](https://habr.com/ru/companies/dododev/articles/489352/)
- ### [Сущности и объекты значения](https://habr.com/ru/articles/275599/) ^2fd95f
- ### [Плейлист по DDD не полный](https://youtube.com/playlist?list=PLvP6XNj3GUhDNDq9KMC_9icY3MrFIR-PQ&si=PlZzaEzW3tOMAhvp)
- ### [Агрегаты](https://habr.com/ru/articles/660599/) ^0004d2
- ### [Еще статья про агрегаты](https://habr.com/ru/articles/543424/)
---
# Cостоит из 

``` math
	DDD = MDD + UL
	MDD - разработка, ведомая моделью
	UL - унифицированный язык
```

## UL

> UL — Единый язык, выстроенный между командой разработки и представителями бизнеса, позволяет выудить из бизнеса полное понимание требований и сделать нашу работу не сказать, что проще — но более нацеленной на будущее. Он позволяет делать так, чтобы эту модель мы каким-то образом могли построить. [[DDD (domain driven development)#^42bead|источник]]
### Что делать?
1)  Составлять словарь из терминов, которые вы используете в повседневной рабочей деятельности
2) Присваивать каждому термину конкретное значение для уменьшения расхождений в понимании разными ролями в вашем проекте и у стейкхолдеров

![[DDD_1.png|Что можно добавлять в словарь]]

3) Ограничивать термины контекстами.
4) Одно английское слово на один термин и единообразие во всем коде 
5) Избегать многозначных терминов 
6) Рефакторить код при смене названия
 ___
## MDD

> **MDD** — это всё, что касается тактических шаблонов проектирования, моделирования и абстрагирования подходов к тому, как это делать. Есть много вопросов, которые пересекаются с моделированием, например, impact mapping или event storming.  [[DDD (domain driven development)#^42bead|источник]]

1)  Определение поддоменов, затронутых требованиями

>**Поддомены** — это области знаний с точки зрения бизнеса. Можно сказать, что мы просто разбиваем всю область знаний на небольшие подобласти и говорим: здесь у нас важная часть, которая приносит максимальную ценность, а там — не очень важная, и она приносит меньше ценности. [[DDD (domain driven development)#^42bead|источник]]

![[DDD_2.png|Разделение на поддомены]]

 2) Определяем тип подобласти
 3) Определяем ограниченные контексты для внесения изменений
 
>**Ограниченные контексты** — термин, больше касающийся разработки. Он предполагает часть решения, в которой термины единого языка имеют однозначное определение. В ограниченный контекст могут входить системы и процессы, которые уже автоматизированы. Контексты ограничивают модели предметной области. [[DDD (domain driven development)#^42bead|источник]]

4) Определяем агрегаты, подверженные изменениям
5) Микросервисы на основе агрегатов

---
# Реализация

## Entity

Сущность в рамках программного решения отвечает за непрерывное существование объекта который представляет во время всего его использование программой. Содержит набор полей, который характеризует черты объекта и на основании которых можно однозначно определить объект.

## Value_Objects

Объекты, не имеющие физического представления, как сущность. В первую очередь в них нас интересуют именно значения. Подробные отличия читать в [[DDD (domain driven development)#^2fd95f|статье]].

>В вопросе объектов-значений и сущностей важное значение имеет следующее правило: всегда предпочитайте объекты-значения сущностям. Объекты-значения неизменяемы и из-за этого с ними крайне просто работать. В идеале, вы всегда должны стремиться включить большинство бизнес-логики в объекты-значения. Сущности в таких ситуациях будут служить обертками над ними и представлять более высокоуровневую функциональность. [[DDD (domain driven development)#^2fd95f|источник]]

Основные различия entity и value_objects:

- Сущности имеют свою собственную, внутренне присущую им идентичность. Объекты-значения — нет.  
- Понятие эквивалентности идентификаторов относится к сущностям; понятие структурной эквивалентности — к объектам-значениям; ссылочной эквивалентности — к обоим.  
- Сущности имеют историю; у объектов-значений нулевой жизненный цикл.  
- Объект-значение всегда должен принадлежать одной или нескольким сущностям, он не может жить собственной жизнью.  
- Объекты-значения должны быть неизменяемыми; сущности почти всегда изменяемы.  
- Чтобы распознать объект-значение, мысленно замените его на integer.  
- Объекты-значения не должны иметь собственной таблицы в БД.  
- Предпочитайте объекты-значения сущностям при моделировании домена.

## Agregate

Ограничения:
- Агрегаты не должны иметь циклических связей.
- Агрегаты должны определять область жизни всех сущностей, в них входящих. Эта область определяется областью жизни корня агрегата. Некорневые сущности не могут появляться раньше корня и продолжать существовать после его удаления.
- Агрегаты должны обеспечивать соблюдение инвариантов. Агрегаты предоставляют такое API, которое не позволит клиенту перевести модель в невалидное состояние.
- Агрегаты должны обеспечивать возможность реализовать все операции системы так, чтобы в одной транзакции менялся (или удалялся) один агрегат. Притом речь идёт именно об изменении (в том числе в виде удаления) существующих агрегатов - создавать и читать можно сколько угодно агрегатов.
- Агрегаты должны быть минимального необходимого размера. Имеется в виду и количество типов сущностей в агрегате, и количество экземпляров сущностей и их размер в байтах.
- Агрегаты должны храниться целиком в одной системе хранения данных на одном узле. Разные агрегаты одной системы могут храниться на разных узлах или в разных хранилищах.
- Агрегаты могут ссылаться на другие агрегаты только через идентификаторы корней. Внутри агрегата сущности могут свободно ссылаться друг на друга.
[[DDD (domain driven development)#^0004d2|источник]]

